# name: Deploy MERN CRUD App

# on:
#   push:
#     branches: [main]
#   workflow_dispatch: # Allow manual triggering

# env:
#   CLIENT_IMAGE: test-practice-client
#   SERVER_IMAGE: test-practice-server
#   DEPLOY_PATH: /var/www/html/Test-practice

# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     timeout-minutes: 30

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       # --- VALIDATION ---
#       - name: Validate required secrets
#         run: |
#           if [ -z "${{ secrets.MONGO_URI }}" ] || [ -z "${{ secrets.JWT_SECRET }}" ]; then
#             echo "âŒ Missing required secrets"
#             exit 1
#           fi
#           echo "âœ… All required secrets are present"

#       # --- CREATE .env FOR SERVER ---
#       - name: Create .env file for server
#         run: |
#           mkdir -p server
#           cat > server/.env << EOF
#           PORT=${{ secrets.SERVER_PORT || '5000' }}
#           MONGO_URI=${{ secrets.MONGO_URI }}
#           JWT_SECRET=${{ secrets.JWT_SECRET }}
#           NODE_ENV=production
#           EOF
#           echo "âœ… Server .env file created"

#       # --- CLIENT BUILD ---
#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: "22.14.0"
#           cache: "npm"
#           cache-dependency-path: client/package-lock.json

#       - name: Install and build client
#         working-directory: ./client
#         run: |
#           echo "ğŸ“¦ Installing client dependencies..."
#           npm ci
#           echo "ğŸ—ï¸ Building client..."
#           npm run build
#           echo "âœ… Client build completed"

#       # --- DOCKER OPERATIONS ---
#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v3

#       - name: Build and save client image
#         run: |
#           echo "ğŸ³ Building client Docker image..."
#           docker build -t ${{ env.CLIENT_IMAGE }}:latest ./client
#           echo "ğŸ’¾ Saving client image to tar..."
#           docker save -o client.tar ${{ env.CLIENT_IMAGE }}:latest
#           # Fix permissions for the tar file
#           chmod 644 client.tar
#           echo "âœ… Client image saved ($(du -h client.tar | cut -f1))"

#       - name: Build and save server image
#         run: |
#           echo "ğŸ³ Building server Docker image..."
#           docker build -t ${{ env.SERVER_IMAGE }}:latest ./server
#           echo "ğŸ’¾ Saving server image to tar..."
#           docker save -o server.tar ${{ env.SERVER_IMAGE }}:latest
#           # Fix permissions for the tar file
#           chmod 644 server.tar
#           echo "âœ… Server image saved ($(du -h server.tar | cut -f1))"

#       # --- BACKUP MANAGEMENT ---
#       - name: Prepare deployment files
#         run: |
#           # Ensure files exist and have correct permissions
#           ls -la *.tar

#           echo "ğŸ“‹ Deployment summary:"
#           echo "- Client tar: $(du -h client.tar | cut -f1)"
#           echo "- Server tar: $(du -h server.tar | cut -f1)"
#           echo "- Total size: $(du -ch *.tar | tail -1 | cut -f1)"

#           # Verify tar files are readable
#           if docker load -i client.tar --quiet && docker load -i server.tar --quiet; then
#             echo "âœ… Tar files verified successfully"
#           else
#             echo "âŒ Tar file verification failed"
#             exit 1
#           fi

#       # --- DEPLOY FILES TO SERVER ---
#       - name: Copy deployment files to server
#         id: copy-files
#         uses: appleboy/scp-action@v0.1.7
#         with:
#           host: ${{ secrets.HOST }}
#           username: ${{ secrets.USERNAME }}
#           key: ${{ secrets.SSH_KEY }}
#           port: ${{ secrets.SSH_PORT || '2025' }}
#           source: "./client.tar,./server.tar"
#           target: ${{ env.DEPLOY_PATH }}
#           timeout: 300s
#           overwrite: true

#       # --- REMOTE DEPLOYMENT ---
#       - name: Deploy Docker containers on remote server
#         uses: appleboy/ssh-action@v1.0.3
#         with:
#           host: ${{ secrets.HOST }}
#           username: ${{ secrets.USERNAME }}
#           key: ${{ secrets.SSH_KEY }}
#           port: ${{ secrets.SSH_PORT || '2025' }}
#           timeout: 300s
#           script: |
#             set -e
#             cd ${{ env.DEPLOY_PATH }}

#             echo "ğŸ” Current directory: $(pwd)"
#             echo "ğŸ“ Available files: $(ls -la *.tar 2>/dev/null || echo 'No tar files found')"

#             # Create backup of current containers
#             echo "ğŸ’¾ Creating backup of current containers..."
#             docker-compose down --remove-orphans || echo "âš ï¸ No existing containers to stop"

#             # Load new images
#             echo "ğŸ³ Loading new Docker images..."
#             if [ -f client.tar ]; then
#               docker load -i client.tar
#               echo "âœ… Client image loaded"
#             else
#               echo "âŒ client.tar not found"
#               exit 1
#             fi

#             if [ -f server.tar ]; then
#               docker load -i server.tar
#               echo "âœ… Server image loaded"
#             else
#               echo "âŒ server.tar not found"
#               exit 1
#             fi

#             # Clean up old images (keep last 2 versions)
#             echo "ğŸ§¹ Cleaning up old images..."
#             docker image prune -f

#             # Start new containers
#             echo "ğŸš€ Starting new containers..."
#             if [ -f docker-compose.yml ]; then
#               docker-compose up -d --remove-orphans
#               echo "âœ… Containers started successfully"

#               # Health check
#               echo "ğŸ¥ Performing health check..."
#               sleep 10
#               docker-compose ps

#               # Verify containers are running
#               if docker-compose ps | grep -q "Up"; then
#                 echo "âœ… Deployment successful!"
#               else
#                 echo "âŒ Some containers failed to start"
#                 docker-compose logs --tail=50
#                 exit 1
#               fi
#             else
#               echo "âŒ docker-compose.yml not found"
#               exit 1
#             fi

#             # Cleanup tar files after successful deployment
#             echo "ğŸ§¹ Cleaning up deployment files..."
#             rm -f client.tar server.tar
#             echo "âœ… Deployment completed successfully"

#       # --- ROLLBACK ON FAILURE ---
#       - name: Rollback on deployment failure
#         if: failure() && steps.copy-files.conclusion != 'failure'
#         uses: appleboy/ssh-action@v1.0.3
#         with:
#           host: ${{ secrets.HOST }}
#           username: ${{ secrets.USERNAME }}
#           key: ${{ secrets.SSH_KEY }}
#           port: ${{ secrets.SSH_PORT || '2025' }}
#           timeout: 60s
#           script: |
#             cd ${{ env.DEPLOY_PATH }} || exit 1
#             echo "ğŸ”„ Attempting rollback..."

#             # Check if docker-compose.yml exists
#             if [ ! -f docker-compose.yml ]; then
#               echo "âŒ docker-compose.yml not found - cannot rollback"
#               exit 1
#             fi

#             # Try to restart with previous images
#             echo "â¹ï¸ Stopping current containers..."
#             docker-compose down --remove-orphans || true

#             echo "ğŸš€ Starting previous containers..."
#             docker-compose up -d || {
#               echo "âŒ Failed to start containers during rollback"
#               exit 1
#             }

#             # Wait a moment for containers to start
#             sleep 5

#             if docker-compose ps | grep -q "Up"; then
#               echo "âœ… Rollback successful"
#             else
#               echo "âŒ Rollback failed - manual intervention required"
#               echo "ğŸ“‹ Container status:"
#               docker-compose ps
#               echo "ğŸ“‹ Recent logs:"
#               docker-compose logs --tail=20
#             fi

#       # --- NOTIFICATION ---
#       - name: Deployment status notification
#         if: always()
#         run: |
#           if [ "${{ job.status }}" == "success" ]; then
#             echo "ğŸ‰ Deployment completed successfully!"
#             echo "ğŸŒ Application should be available at your configured domain"
#           else
#             echo "âŒ Deployment failed. Check the logs above for details."
#             echo "ğŸ”„ Rollback may have been attempted automatically."
#           fi

name: Deploy MERN CRUD App

on:
  push:
    branches: [main]
  workflow_dispatch: # Allow manual triggering

env:
  CLIENT_IMAGE: test-practice-client
  SERVER_IMAGE: test-practice-server
  DEPLOY_PATH: /var/www/html/Test-practice

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      client-changed: ${{ steps.changes.outputs.client }}
      server-changed: ${{ steps.changes.outputs.server }}
      docker-compose-changed: ${{ steps.changes.outputs.docker-compose }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            client:
              - 'client/**'
            server:
              - 'server/**'
            docker-compose:
              - 'docker-compose.yml'
              - 'docker-compose.yaml'

  deploy:
    needs: detect-changes
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: ${{ needs.detect-changes.outputs.client-changed == 'true' || needs.detect-changes.outputs.server-changed == 'true' || needs.detect-changes.outputs.docker-compose-changed == 'true' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --- DISPLAY CHANGES ---
      - name: Display detected changes
        run: |
          echo "ğŸ” Change Detection Results:"
          echo "- Client changed: ${{ needs.detect-changes.outputs.client-changed }}"
          echo "- Server changed: ${{ needs.detect-changes.outputs.server-changed }}"
          echo "- Docker Compose changed: ${{ needs.detect-changes.outputs.docker-compose-changed }}"

          if [ "${{ needs.detect-changes.outputs.client-changed }}" == "true" ]; then
            echo "ğŸ“¦ Will build and deploy CLIENT"
          fi
          if [ "${{ needs.detect-changes.outputs.server-changed }}" == "true" ]; then
            echo "ğŸš€ Will build and deploy SERVER"
          fi
          if [ "${{ needs.detect-changes.outputs.docker-compose-changed }}" == "true" ]; then
            echo "ğŸ³ Docker Compose configuration changed"
          fi

      # --- VALIDATION ---
      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.MONGO_URI }}" ] || [ -z "${{ secrets.JWT_SECRET }}" ]; then
            echo "âŒ Missing required secrets"
            exit 1
          fi
          echo "âœ… All required secrets are present"

      # --- CREATE .env FOR SERVER (only if server changed) ---
      - name: Create .env file for server
        if: needs.detect-changes.outputs.server-changed == 'true'
        run: |
          mkdir -p server
          cat > server/.env << EOF
          PORT=${{ secrets.SERVER_PORT || '5000' }}
          MONGO_URI=${{ secrets.MONGO_URI }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          NODE_ENV=production
          EOF
          echo "âœ… Server .env file created"

      # --- CLIENT BUILD (only if client changed) ---
      - name: Setup Node.js for client
        if: needs.detect-changes.outputs.client-changed == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "22.14.0"
          cache: "npm"
          cache-dependency-path: client/package-lock.json

      - name: Install and build client
        if: needs.detect-changes.outputs.client-changed == 'true'
        working-directory: ./client
        run: |
          echo "ğŸ“¦ Installing client dependencies..."
          npm ci
          echo "ğŸ—ï¸ Building client..."
          npm run build
          echo "âœ… Client build completed"

      # --- DOCKER OPERATIONS ---
      - name: Set up Docker Buildx
        if: needs.detect-changes.outputs.client-changed == 'true' || needs.detect-changes.outputs.server-changed == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and save client image
        if: needs.detect-changes.outputs.client-changed == 'true'
        run: |
          echo "ğŸ³ Building client Docker image..."
          docker build -t ${{ env.CLIENT_IMAGE }}:latest ./client
          echo "ğŸ’¾ Saving client image to tar..."
          docker save -o client.tar ${{ env.CLIENT_IMAGE }}:latest
          # Fix permissions for the tar file
          chmod 644 client.tar
          echo "âœ… Client image saved ($(du -h client.tar | cut -f1))"

      - name: Build and save server image
        if: needs.detect-changes.outputs.server-changed == 'true'
        run: |
          echo "ğŸ³ Building server Docker image..."
          docker build -t ${{ env.SERVER_IMAGE }}:latest ./server
          echo "ğŸ’¾ Saving server image to tar..."
          docker save -o server.tar ${{ env.SERVER_IMAGE }}:latest
          # Fix permissions for the tar file
          chmod 644 server.tar
          echo "âœ… Server image saved ($(du -h server.tar | cut -f1))"

      # --- PREPARE DEPLOYMENT FILES ---
      - name: Prepare deployment files
        run: |
          # Create a list of files to deploy
          FILES_TO_DEPLOY=""

          if [ "${{ needs.detect-changes.outputs.client-changed }}" == "true" ] && [ -f client.tar ]; then
            FILES_TO_DEPLOY="$FILES_TO_DEPLOY,./client.tar"
            echo "ğŸ“¦ Client tar ready: $(du -h client.tar | cut -f1)"
          fi

          if [ "${{ needs.detect-changes.outputs.server-changed }}" == "true" ] && [ -f server.tar ]; then
            FILES_TO_DEPLOY="$FILES_TO_DEPLOY,./server.tar"
            echo "ğŸš€ Server tar ready: $(du -h server.tar | cut -f1)"
          fi

          # Remove leading comma
          FILES_TO_DEPLOY=$(echo $FILES_TO_DEPLOY | sed 's/^,//')

          if [ -z "$FILES_TO_DEPLOY" ]; then
            echo "âŒ No files to deploy"
            exit 1
          fi

          echo "FILES_TO_DEPLOY=$FILES_TO_DEPLOY" >> $GITHUB_ENV
          echo "ğŸ“‹ Files to deploy: $FILES_TO_DEPLOY"

          # Verify tar files if they exist
          if [ -f client.tar ]; then
            docker load -i client.tar --quiet && echo "âœ… Client tar verified"
          fi
          if [ -f server.tar ]; then
            docker load -i server.tar --quiet && echo "âœ… Server tar verified"
          fi

      # --- DEPLOY FILES TO SERVER ---
      - name: Copy deployment files to server
        id: copy-files
        if: env.FILES_TO_DEPLOY != ''
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || '2025' }}
          source: ${{ env.FILES_TO_DEPLOY }}
          target: ${{ env.DEPLOY_PATH }}
          timeout: 300s
          overwrite: true

      # --- REMOTE DEPLOYMENT ---
      - name: Deploy Docker containers on remote server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || '2025' }}
          timeout: 300s
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "ğŸ” Current directory: $(pwd)"
            echo "ğŸ“ Available files: $(ls -la *.tar 2>/dev/null || echo 'No tar files found')"

            # Load images based on what was deployed
            CLIENT_CHANGED="${{ needs.detect-changes.outputs.client-changed }}"
            SERVER_CHANGED="${{ needs.detect-changes.outputs.server-changed }}"
            DOCKER_COMPOSE_CHANGED="${{ needs.detect-changes.outputs.docker-compose-changed }}"

            echo "ğŸ³ Loading updated Docker images..."

            if [ "$CLIENT_CHANGED" == "true" ] && [ -f client.tar ]; then
              echo "ğŸ“¦ Loading client image..."
              docker load -i client.tar
              echo "âœ… Client image loaded"
            else
              echo "â­ï¸ Skipping client image (no changes)"
            fi

            if [ "$SERVER_CHANGED" == "true" ] && [ -f server.tar ]; then
              echo "ğŸš€ Loading server image..."
              docker load -i server.tar  
              echo "âœ… Server image loaded"
            else
              echo "â­ï¸ Skipping server image (no changes)"
            fi

            # Check if we need to restart containers
            NEEDS_RESTART="false"
            if [ "$CLIENT_CHANGED" == "true" ] || [ "$SERVER_CHANGED" == "true" ] || [ "$DOCKER_COMPOSE_CHANGED" == "true" ]; then
              NEEDS_RESTART="true"
            fi

            if [ "$NEEDS_RESTART" == "true" ]; then
              echo "ğŸ”„ Restarting containers with updated images..."
              
              # Create backup of current containers
              echo "ğŸ’¾ Stopping current containers..."
              docker-compose down --remove-orphans || echo "âš ï¸ No existing containers to stop"
              
              # Clean up old images (keep last 2 versions)
              echo "ğŸ§¹ Cleaning up old images..."
              docker image prune -f
              
              # Start containers
              echo "ğŸš€ Starting containers..."
              if [ -f docker-compose.yml ]; then
                docker-compose up -d --remove-orphans
                echo "âœ… Containers started successfully"
                
                # Health check
                echo "ğŸ¥ Performing health check..."
                sleep 10
                docker-compose ps
                
                # Verify containers are running
                if docker-compose ps | grep -q "Up"; then
                  echo "âœ… Deployment successful!"
                  
                  # Show what was updated
                  if [ "$CLIENT_CHANGED" == "true" ]; then
                    echo "ğŸ“¦ Client updated and deployed"
                  fi
                  if [ "$SERVER_CHANGED" == "true" ]; then
                    echo "ğŸš€ Server updated and deployed"
                  fi
                  if [ "$DOCKER_COMPOSE_CHANGED" == "true" ]; then
                    echo "ğŸ³ Docker Compose configuration updated"
                  fi
                else
                  echo "âŒ Some containers failed to start"
                  docker-compose logs --tail=50
                  exit 1
                fi
              else
                echo "âŒ docker-compose.yml not found"
                exit 1
              fi
            else
              echo "â­ï¸ No restart needed - no relevant changes detected"
            fi

            # Cleanup tar files after successful deployment
            echo "ğŸ§¹ Cleaning up deployment files..."
            rm -f client.tar server.tar
            echo "âœ… Deployment completed successfully"

      # --- ROLLBACK ON FAILURE ---
      - name: Rollback on deployment failure
        if: failure() && steps.copy-files.conclusion != 'failure'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || '2025' }}
          timeout: 60s
          script: |
            cd ${{ env.DEPLOY_PATH }} || exit 1
            echo "ğŸ”„ Attempting rollback..."

            # Check if docker-compose.yml exists
            if [ ! -f docker-compose.yml ]; then
              echo "âŒ docker-compose.yml not found - cannot rollback"
              exit 1
            fi

            # Try to restart with previous images
            echo "â¹ï¸ Stopping current containers..."
            docker-compose down --remove-orphans || true

            echo "ğŸš€ Starting previous containers..."
            docker-compose up -d || {
              echo "âŒ Failed to start containers during rollback"
              exit 1
            }

            # Wait a moment for containers to start
            sleep 5

            if docker-compose ps | grep -q "Up"; then
              echo "âœ… Rollback successful"
            else
              echo "âŒ Rollback failed - manual intervention required"
              echo "ğŸ“‹ Container status:"
              docker-compose ps
              echo "ğŸ“‹ Recent logs:"
              docker-compose logs --tail=20
            fi

      # --- NOTIFICATION ---
      - name: Deployment status notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "ğŸ‰ Selective deployment completed successfully!"
            
            if [ "${{ needs.detect-changes.outputs.client-changed }}" == "true" ]; then
              echo "ğŸ“¦ Client was updated and deployed"
            fi
            if [ "${{ needs.detect-changes.outputs.server-changed }}" == "true" ]; then
              echo "ğŸš€ Server was updated and deployed"
            fi
            if [ "${{ needs.detect-changes.outputs.docker-compose-changed }}" == "true" ]; then
              echo "ğŸ³ Docker Compose configuration was updated"
            fi
            
            echo "ğŸŒ Application should be available at your configured domain"
          else
            echo "âŒ Deployment failed. Check the logs above for details."
            echo "ğŸ”„ Rollback may have been attempted automatically."
          fi

  # --- SKIP JOB ---
  skip-deployment:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: ${{ needs.detect-changes.outputs.client-changed != 'true' && needs.detect-changes.outputs.server-changed != 'true' && needs.detect-changes.outputs.docker-compose-changed != 'true' }}
    steps:
      - name: No deployment needed
        run: |
          echo "â­ï¸ No relevant changes detected in this push"
          echo "ğŸ¯ Only deploying when changes are made to:"
          echo "   - client/ directory (frontend)"
          echo "   - server/ directory (backend)"  
          echo "   - docker-compose.yml file"
          echo "âœ… Workflow completed - no deployment necessary"
